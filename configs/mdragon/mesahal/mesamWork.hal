# core HAL config file for simulation - 4 axis

# load RT modules
loadrt [KINS]KINEMATICS
loadrt [EMCMOT]EMCMOT   servo_period_nsec=[EMCMOT]SERVO_PERIOD num_joints=[KINS]JOINTS  num_dio=20
loadrt ddt count=8
#base_period_nsec=[EMCMOT]BASE_PERIOD
# load parameters save

# hostmot2 driver
loadrt hostmot2
loadrt hm2_eth board_ip="10.10.10.10" config=" num_encoders=1 num_pwmgens=1 num_stepgens=4 sserial_port_0=20000000 ssi_chan_0=steps%2bzencoder%12um enable_raw" 
setp   hm2_7i80.0.watchdog.timeout_ns 60000000
loadrt sum2 count=1
#pwm gen
#loadrt pwmgen output_type=0
#BASE_PERIOD
addf sum2.0 servo-thread
addf hm2_7i80.0.read          servo-thread
addf motion-command-handler   servo-thread
addf motion-controller        servo-thread
addf hm2_7i80.0.write         servo-thread
#addf pwmgen.make-pulses 	  base-thread 
#addf pwmgen.update			  servo-thread
setp hm2_7i80.0.dpll.01.timer-us -50
setp hm2_7i80.0.dpll.02.timer-us -120
setp hm2_7i80.0.dpll.03.timer-us -200
setp hm2_7i80.0.dpll.04.timer-us -200
setp hm2_7i80.0.stepgen.timer-number 1
setp hm2_7i80.0.packet-error-limit  500

setp scarakins.D1 400.0
setp scarakins.D2 350.0
setp scarakins.D3 75.0
setp scarakins.D4 350.0
setp scarakins.D5 200.0
setp scarakins.D6 0.0

addf ddt.0 servo-thread
addf ddt.1 servo-thread
addf ddt.2 servo-thread
addf ddt.3 servo-thread
addf ddt.4 servo-thread
addf ddt.5 servo-thread
addf ddt.6 servo-thread
addf ddt.7 servo-thread

#Laser

setp hm2_7i80.0.pwmgen.00.out0.invert_output  1
setp hm2_7i80.0.pwmgen.pwm_frequency 5000
setp hm2_7i80.0.pwmgen.00.scale 5000
setp hm2_7i80.0.pwmgen.00.output-type 1

net spindle-speed-cmd spindle.0.speed-out => hm2_[HOSTMOT2](BOARD).0.pwmgen.00.value
net spindle-on spindle.0.on => hm2_[HOSTMOT2](BOARD).0.pwmgen.00.enable
#End

# create HAL signals for position commands from motion module
net J0pos hm2_[HOSTMOT2](BOARD).0.stepgen.00.position-cmd <= joint.0.motor-pos-cmd
net J1pos hm2_[HOSTMOT2](BOARD).0.stepgen.01.position-cmd <= joint.1.motor-pos-cmd

#set gain for sum2 = in0*gain0 + in1*gain1
setp sum2.0.gain0 1
#gain1 = (gear-cAxis/gear-zAxis)
setp sum2.0.gain1 0.069333333333337
net J2pos sum2.0.in0 <= joint.2.motor-pos-cmd
net J3pos hm2_[HOSTMOT2](BOARD).0.stepgen.03.position-cmd sum2.0.in1 <= joint.3.motor-pos-cmd
net J2posE hm2_[HOSTMOT2](BOARD).0.stepgen.02.position-cmd <= sum2.0.out 

# timing parameters
setp hm2_7i80.0.stepgen.00.dirsetup        [JOINT_0]DIRSETUP
setp hm2_7i80.0.stepgen.00.dirhold         [JOINT_0]DIRHOLD
setp hm2_7i80.0.stepgen.00.steplen         [JOINT_0]STEPLEN
setp hm2_7i80.0.stepgen.00.stepspace       [JOINT_0]STEPSPACE
setp hm2_7i80.0.stepgen.00.position-scale  [JOINT_0]STEP_SCALE
setp hm2_7i80.0.stepgen.00.maxvel          [JOINT_0]STEPGEN_MAX_VEL
setp hm2_7i80.0.stepgen.00.maxaccel        [JOINT_0]STEPGEN_MAX_ACC
setp hm2_7i80.0.stepgen.00.step_type       0

setp hm2_7i80.0.stepgen.01.dirsetup        [JOINT_1]DIRSETUP
setp hm2_7i80.0.stepgen.01.dirhold         [JOINT_1]DIRHOLD
setp hm2_7i80.0.stepgen.01.steplen         [JOINT_1]STEPLEN
setp hm2_7i80.0.stepgen.01.stepspace       [JOINT_1]STEPSPACE
setp hm2_7i80.0.stepgen.01.position-scale  [JOINT_1]STEP_SCALE
setp hm2_7i80.0.stepgen.01.maxvel          [JOINT_1]STEPGEN_MAX_VEL
setp hm2_7i80.0.stepgen.01.maxaccel        [JOINT_1]STEPGEN_MAX_ACC
setp hm2_7i80.0.stepgen.01.step_type       0

setp hm2_7i80.0.stepgen.02.dirsetup        [JOINT_2]DIRSETUP
setp hm2_7i80.0.stepgen.02.dirhold         [JOINT_2]DIRHOLD
setp hm2_7i80.0.stepgen.02.steplen         [JOINT_2]STEPLEN
setp hm2_7i80.0.stepgen.02.stepspace       [JOINT_2]STEPSPACE
setp hm2_7i80.0.stepgen.02.position-scale  [JOINT_2]STEP_SCALE
setp hm2_7i80.0.stepgen.02.maxvel          [JOINT_2]STEPGEN_MAX_VEL
setp hm2_7i80.0.stepgen.02.maxaccel        [JOINT_2]STEPGEN_MAX_ACC
setp hm2_7i80.0.stepgen.02.step_type       0

setp hm2_7i80.0.stepgen.03.dirsetup        [JOINT_3]DIRSETUP
setp hm2_7i80.0.stepgen.03.dirhold         [JOINT_3]DIRHOLD
setp hm2_7i80.0.stepgen.03.steplen         [JOINT_3]STEPLEN
setp hm2_7i80.0.stepgen.03.stepspace       [JOINT_3]STEPSPACE
setp hm2_7i80.0.stepgen.03.position-scale  [JOINT_3]STEP_SCALE
setp hm2_7i80.0.stepgen.03.maxvel          [JOINT_3]STEPGEN_MAX_VEL
setp hm2_7i80.0.stepgen.03.maxaccel        [JOINT_3]STEPGEN_MAX_ACC
setp hm2_7i80.0.stepgen.03.step_type       0

# loop position commands back to motion module feedback
#mwork: close loop
#net motor.00.pos-fb <= hm2_[HOSTMOT2](BOARD).0.stepgen.00.position-fb
#net motor.00.pos-fb => joint.0.motor-pos-fb
#mwork: open loop
net J0pos => joint.0.motor-pos-fb
net J1pos => joint.1.motor-pos-fb
net J3pos => joint.3.motor-pos-fb
net J2pos => joint.2.motor-pos-fb

setp hm2_7i80.0.ssi.00.frequency-khz 300  
setp hm2_7i80.0.ssi.00.timer-number 2
setp hm2_7i80.0.ssi.00.zencoder-scalemax 0.5
#setp hm2_7i80.0.ssi.00.zencoder.scale 535
#setp hm2_7i80.0.ssi.00.zencoder.index-enable 0
#setp hm2_7i80.0.ssi.00.zencoder.counts-per-rev 4095
net z-pos-fbss  hm2_7i80.0.ssi.00.zencoder
#.position
#net z-pos-fb => joint.2.motor-pos-fb
#net z-pos-rawcountsww <= hm2_7i80.0.ssi.00.zencoder.rawcounts
#setp hm2_7i80.0.raw.read_address 0x6900 
#show pin hm2_7i80.0.read_data
# send the position commands thru differentiators to
# generate velocity and accel signals
# define the signals, and hook them up

net J0pos => ddt.0.in
net J0vel <= ddt.0.out
net J0vel => ddt.1.in
net J0acc <= ddt.1.out

net J1pos => ddt.2.in
net J1vel <= ddt.2.out
net J1vel => ddt.3.in
net J1acc <= ddt.3.out

net J2pos => ddt.4.in
net J2vel <= ddt.4.out
net J2vel => ddt.5.in
net J2acc <= ddt.5.out

net J3pos => ddt.6.in
net J3vel <= ddt.6.out
net J3vel => ddt.7.in
net J3acc <= ddt.7.out

# estop loopback
net estop-loop iocontrol.0.user-enable-out iocontrol.0.emc-enable-in

# create signals for tool loading loopback
net tool-prep-loop iocontrol.0.tool-prepare iocontrol.0.tool-prepared
net tool-change-loop iocontrol.0.tool-change iocontrol.0.tool-changed



# add motion controller functions to servo thread

setp hm2_[HOSTMOT2](BOARD).0.gpio.034.is_output true  #1
setp hm2_[HOSTMOT2](BOARD).0.gpio.036.is_output true  #2
setp hm2_[HOSTMOT2](BOARD).0.gpio.038.is_output true  #3
setp hm2_[HOSTMOT2](BOARD).0.gpio.040.is_output true  #4
setp hm2_[HOSTMOT2](BOARD).0.gpio.042.is_output true  #5
setp hm2_[HOSTMOT2](BOARD).0.gpio.043.is_output true  #6
setp hm2_[HOSTMOT2](BOARD).0.gpio.044.is_output true  #7
setp hm2_[HOSTMOT2](BOARD).0.gpio.045.is_output true  #8
#setp hm2_[HOSTMOT2](BOARD).0.gpio.046.is_output true
#setp hm2_[HOSTMOT2](BOARD).0.gpio.047.is_output true
#setp hm2_[HOSTMOT2](BOARD).0.gpio.048.is_output true
#setp hm2_[HOSTMOT2](BOARD).0.gpio.049.is_output true
#setp hm2_[HOSTMOT2](BOARD).0.gpio.050.is_output true
setp hm2_[HOSTMOT2](BOARD).0.gpio.035.is_output true
setp hm2_[HOSTMOT2](BOARD).0.gpio.037.is_output true
setp hm2_[HOSTMOT2](BOARD).0.gpio.039.is_output true
setp hm2_[HOSTMOT2](BOARD).0.gpio.041.is_output true
setp hm2_[HOSTMOT2](BOARD).0.gpio.034.invert_output true
setp hm2_[HOSTMOT2](BOARD).0.gpio.035.invert_output true
setp hm2_[HOSTMOT2](BOARD).0.gpio.036.invert_output true
setp hm2_[HOSTMOT2](BOARD).0.gpio.037.invert_output true
setp hm2_[HOSTMOT2](BOARD).0.gpio.038.invert_output true
setp hm2_[HOSTMOT2](BOARD).0.gpio.039.invert_output true
setp hm2_[HOSTMOT2](BOARD).0.gpio.040.invert_output true
setp hm2_[HOSTMOT2](BOARD).0.gpio.041.invert_output true
setp hm2_[HOSTMOT2](BOARD).0.gpio.042.invert_output true
setp hm2_[HOSTMOT2](BOARD).0.gpio.043.invert_output true
setp hm2_[HOSTMOT2](BOARD).0.gpio.044.invert_output true
setp hm2_[HOSTMOT2](BOARD).0.gpio.045.invert_output true
#setp hm2_[HOSTMOT2](BOARD).0.gpio.040.invert_output true
#setp hm2_[HOSTMOT2](BOARD).0.gpio.040.invert_output true
#setp hm2_[HOSTMOT2](BOARD).0.gpio.048.invert_output true
#setp hm2_[HOSTMOT2](BOARD).0.gpio.049.invert_output true
#setp hm2_[HOSTMOT2](BOARD).0.gpio.050.invert_output true
net xena joint.0.amp-enable-out => hm2_[HOSTMOT2](BOARD).0.stepgen.00.enable
net xena => hm2_[HOSTMOT2](BOARD).0.gpio.034.out
net yena joint.1.amp-enable-out => hm2_[HOSTMOT2](BOARD).0.stepgen.01.enable
net yena joint.1.amp-enable-out => hm2_[HOSTMOT2](BOARD).0.gpio.036.out
net zena joint.2.amp-enable-out => hm2_[HOSTMOT2](BOARD).0.stepgen.02.enable
net zena joint.2.amp-enable-out => hm2_[HOSTMOT2](BOARD).0.gpio.038.out
net aena joint.3.amp-enable-out => hm2_[HOSTMOT2](BOARD).0.stepgen.03.enable
net aena joint.3.amp-enable-out => hm2_[HOSTMOT2](BOARD).0.gpio.040.out

# Cai home pin 
net homeswitchesX <= hm2_[HOSTMOT2](BOARD).0.gpio.046.in
net homeswitchesX => joint.0.home-sw-in
#net homeswitchesX => joint.0.neg-lim-sw-in
#net homeswitchesX => joint.0.pos-lim-sw-in

net homeswitchesY <= hm2_[HOSTMOT2](BOARD).0.gpio.047.in
net homeswitchesY => joint.1.home-sw-in
#net homeswitchesX => joint.0.neg-lim-sw-in
#net homeswitchesX => joint.0.pos-lim-sw-in
# amp control

net xflt joint.0.amp-fault-in
net yflt joint.1.amp-fault-in
net zflt joint.2.amp-fault-in
net aflt joint.3.amp-fault-in


#loadusr -W mworkscaragui
#loadusr -W scaragui

#net j0 joint.0.pos-fb mworkscaragui.joint0
#net j1 joint.1.pos-fb mworkscaragui.joint1
#net z-pos-fb mworkscaragui.joint2
#net j3 joint.3.pos-fb mworkscaragui.joint3
#net j0 joint.0.pos-fb scaragui.joint0
#net j1 joint.1.pos-fb scaragui.joint1
#net j2 joint.2.pos-fb scaragui.joint2
#net j3 joint.3.pos-fb scaragui.joint3

#setp motion.switchkins-type 1
net :kinstype-select <= motion.analog-out-03 => motion.switchkins-type
#net :kinstype-select <= motion.analog-out-03 => motion.switchkins-type 
#net :kinstype.is-0 <= kinstype.is-0 => pyvcp.multilabel.0.legend0
#net :kinstype.is-1 <= kinstype.is-1 => pyvcp.multilabel.0.legend1
#net :kinstype.is-2 <= kinstype.is-2 => pyvcp.multilabel.0.legend2

#net signal-name motion.digital-in-00 <= parport.0.pin10-in
net pinOut1 motion.digital-out-01 => hm2_[HOSTMOT2](BOARD).0.gpio.042.out
net pinOut0 motion.digital-out-00 => hm2_[HOSTMOT2](BOARD).0.gpio.043.out
net pinOut2 motion.digital-out-02 => hm2_[HOSTMOT2](BOARD).0.gpio.044.out
#net outprogramrun halui.program.is-running => hm2_[HOSTMOT2](BOARD).0.gpio.043.out

#net cyclestart <= hm2_[HOSTMOT2](BOARD).0.gpio.048.in => halui.program.run
net pinIn1 <= hm2_[HOSTMOT2](BOARD).0.gpio.048.in => motion.digital-in-01
net pinIn0 <= hm2_[HOSTMOT2](BOARD).0.gpio.049.in => motion.digital-in-00

#                                 halui.program.run  IN
#Owner   Type  Dir         Value  Name
#    10  bit   IN          FALSE  halui.mode.auto
#    10  bit   OUT         FALSE  halui.mode.is-auto
#    10  bit   OUT          TRUE  halui.mode.is-joint
#    10  bit   OUT          TRUE  halui.mode.is-manual
#    10  bit   OUT         FALSE  halui.mode.is-mdi
#    10  bit   OUT         FALSE  halui.mode.is-teleop
#    10  bit   IN          FALSE  halui.mode.joint
#    10  bit   IN          FALSE  halui.mode.manual
#    10  bit   IN          FALSE  halui.mode.mdi
#    10  bit   IN          FALSE  halui.mode.teleop
#Owner   Type  Dir         Value  Name
#    10  bit   IN          FALSE  halui.estop.activate
#    10  bit   OUT          TRUE  halui.estop.is-activated
#    10  bit   IN          FALSE  halui.estop.reset
#Owner   Type  Dir         Value  Name
#    10  bit   OUT         FALSE  halui.machine.is-on
#    10  bit   IN          FALSE  halui.machine.off
#    10  bit   IN          FALSE  halui.machine.on
#    10  float OUT             1  halui.machine.units-per-mm
#Owner   Type  Dir         Value  Name
#    10  bit   OUT          TRUE  halui.program.block-delete.is-on
#    10  bit   IN          FALSE  halui.program.block-delete.off
#    10  bit   IN          FALSE  halui.program.block-delete.on
#    10  bit   OUT          TRUE  halui.program.is-idle
#    10  bit   OUT         FALSE  halui.program.is-paused
#    10  bit   OUT         FALSE  halui.program.is-running
#    10  bit   OUT          TRUE  halui.program.optional-stop.is-on
#    10  bit   IN          FALSE  halui.program.optional-stop.off
#    10  bit   IN          FALSE  halui.program.optional-stop.on
#    10  bit   IN          FALSE  halui.program.pause
#    10  bit   IN          FALSE  halui.program.resume
#    10  bit   IN          FALSE  halui.program.run
#    10  bit   IN          FALSE  halui.program.step
#    10  bit   IN          FALSE  halui.program.stop